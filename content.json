{"pages":[],"posts":[{"title":"python 기본 문법","text":"1print(&quot;hello, World&quot;) hello, World 주석처리12345# 한줄 주석처리&quot;&quot;&quot;여러 줄 주석 예제 동일한 따옴표(큰 따옴표 혹은 작은 따옴 표) 세 개와 세개 사이는 어떤 내용이 들어가도 주석처리가 된다.&quot;&quot;&quot;print(&quot;Hello&quot;) Hello 변수의 종류12num_int = 1print(type(num_int)) &lt;class 'int'&gt; 12num_float = 0.2print(type(num_float)) &lt;class 'float'&gt; 12bool_true = Trueprint(type(bool_true)) &lt;class 'bool'&gt; 12none_x = Noneprint(type(none_x)) &lt;class 'NoneType'&gt; 논리형 &amp; 비교 연산자 응용12345num1 = int(input(&quot;첫번째 번호 입력&quot;))num2 = int(input(&quot;두번째 번호 입력&quot;))var1 = num1 &gt;= num2print(var1) 첫번째 번호 입력2 두번째 번호 입력2 True String Operators123str1 = &quot;hello &quot;str2 = &quot;world &quot;print(&quot;str1 + str2 = &quot;, str1 + str2) str1 + str2 = hello world 12greet = str1 + str2print('greet * 5 = ', greet *5) greet * 5 = hello world hello world hello world hello world hello world Indexing1234567greeting = &quot;hello Kaggle&quot;print(greeting[:]) # 전체print(greeting[0]) # 0값을 가져옴print(greeting[6:]) # 6부터 끝까지print(greeting[:6]) # 0부터 6까지print(greeting[3:8]) # 3부터 8까지 가져옴print(greeting[0:9:2]) #0부터 9까지 가져오면서 2칸씩 띄우고 가져옴 hello Kaggle h Kaggle hello lo Ka hloKg 리스트123456789a = [] # 빈리스트a_func = list() #list() 함수로도 빈 리스트를 만들 수 있다.b = [1] # 숫자도 요소가 될 수 있다.c = ['apple'] # 문자열도 요소가 될 수 있다.d = [1,2,['apple']] #리스트 안에 리스트를 요소로 넣을 수있다.print(a)print(b)print(c)print(d) [] [1] ['apple'] [1, 2, ['apple']] 123456a = [1, 2, 3]# index [0,1,2]print(a[0]) #첫번째 요소print(a[1]) # 두번째 요소print(a[2]) # 세번째 요소print(a[-1]) 1 2 3 3 123456a = [['apple','banana','cherry']]print(a[0])print(a[0][0]) # 0의 0 인덱스 값print(a[0][0][3]) # 리스트 내의 리스트의 첫번째 문자열 'apple' 중 세번째 인덱스print(a[0][2]) ['apple', 'banana', 'cherry'] apple l cherry 123456789a = [1,2,3,4,5,6,7,8,9,10]b = a[:4] # 인덱스 0부터 3까지c = a[1:4] #인덱스 1부터 3까지d = a[0:7:2] #인덱스 0부터 6까지 인덱스 2칸 건너 띄우기f = a[::2] #리스트 전체구간에서 인덱스 2씩 건너띄우기print(&quot;a[:4] : &quot;,b)print(&quot;a[1:4] : &quot;,c)print(&quot;a[0:7:2] : &quot; , d)print(&quot;a[::2] : &quot;, f) a[:4] : [1, 2, 3, 4] a[1:4] : [2, 3, 4] a[0:7:2] : [1, 3, 5, 7] a[::2] : [1, 3, 5, 7, 9] 12345a = ['alice','bob','cat']b = ['apple','banana','cherry']c = a+bprint(c) ['alice', 'bob', 'cat', 'apple', 'banana', 'cherry'] 리스트 값 수정하기1234a = [0,1,2]a[1] = &quot;b&quot; # 인덱스 1열 수정print(a) [0, 'b', 2] 리스트 값 추가하기123456a = [100,200,300]a.append(400)print(a)a.append([500,600])print(a) [100, 200, 300, 400] [100, 200, 300, 400, [500, 600]] 1234a = [1,2,3]a.extend([40,500])print('a.extend([40,500])result')print(a) a.extend([40,500])result [1, 2, 3, 40, 500] 123456789101112131415a = [0,1,2,3]a[2:2] = [100,200]print(a)# 시작과 끝의 범위 보다 큰 수를 덮어쓰는 예시b = [0,1,2,3]b[1:2] = [100,200,300,400]# 1행에서 1행까지 덮어쓰기print(b)# 시작과 끝의 범위가 작을때의 예시c = [0,1,2,3]c[1:3] = [100] #1행에서 2행까지 덮어쓰기print(c) [0, 1, 100, 200, 2, 3] [0, 100, 200, 300, 400, 2, 3] [0, 100, 3] 리스트 값 삭제하기123456a = [1,2,1,2]#리스트의 첫번째 1이 삭제a.remove(1)print(a) [2, 1, 2] [2, 2] 12345678910a = [0,1,2,3,4,5,6,7,8,9]# 1 삭제del a[1]print(a)b = [0,1,2,3,4,5,6,7,8,9]# 범위로 삭제del b[1:3] #list는 항상 시작하는 인덱스부터 종료하는 n의 n-1까지의 범위를 잡아줍니다.print(b) [0, 2, 3, 4, 5, 6, 7, 8, 9] [0, 3, 4, 5, 6, 7, 8, 9] 123456#인덱스를 지정한 pop()a = [0,1,2,3,4]r = a.pop(1)print(a)print(r) [0, 2, 3, 4] 1 123456# 인덱스를 지정하지 않은 pop()b = ['a','b','c','d']x = b.pop()print(b)print(x) ['a', 'b', 'c'] d 그 외 유용한 메서드12345a = [0,1,2,3]print(a)a.clear()print(a) [0, 1, 2, 3] [] 12a = [&quot;gold&quot;,&quot;gold&quot;,&quot;silver&quot;,&quot;silver&quot;]print(&quot;sliver가 처음 등장하는 인덱스 번호 : &quot; ,a.index(&quot;silver&quot;)) sliver가 처음 등장하는 인덱스 번호 2 12345678a = [1,4,5,2,3]b = [1,4,5,2,3]a.sort()print(&quot;sort() : &quot; ,a) #오름차순b.sort(reverse=True)print(&quot;sort(reverse=True):&quot;,b) #내림차순 sort() : [1, 2, 3, 4, 5] sort(reverse=True): [5, 4, 3, 2, 1] 튜플1234567891011tuple1 =(0) #끝에 콤마(,)를 붙이지 않았을 때tuple2 = (0,) #끝에 콤마(,)를 붙여줬을 때tuple3 = 0,1,2print(tuple1)print(tuple2)print(tuple3)print(type(tuple1)) #콤마(,)를 붙여주지 않으면 튜플이 아닙니다.print(type(tuple2)) #콤마(,)를 붙여주어야 튜플 자료형입니다.print(type(tuple3)) #여러개의 값 일 경우 괄호를 없애주어도 튜플 자료형입니다. 0 (0,) (0, 1, 2) &lt;class 'int'&gt; &lt;class 'tuple'&gt; &lt;class 'tuple'&gt; 더하기 및 곱셈 연산자 사용12345t1 = (0,1,2,3,4)t2 = ('a','b','c')t3 = t1 +t2print(t1+t2)print(t3) (0, 1, 2, 3, 4, 'a', 'b', 'c') (0, 1, 2, 3, 4, 'a', 'b', 'c') 123t1 = ('a','b')print(t1 *0)print(t1 *3) () ('a', 'b', 'a', 'b', 'a', 'b') 딕셔너리1234dic = {'teacher' : &quot;alice&quot;,'class':5,'student' : 15,'list' : [1,2,3]}print(dic['teacher'])print(dic['class'])print(dic['list']) alice 5 [1, 2, 3] 12a = {'name' : 'bob' , 'job' : 'farmer', 'age' : 35}a.keys() #키워드를 찾아주는 메서드 dict_keys(['name', 'job', 'age']) 12a = {'name' : 'bob' , 'job' : 'farmer', 'age' : 35}a.values() #키워드의 정보를 찾아주는 메서드 dict_values(['bob', 'farmer', 35]) 1234a = {'name' : 'cheis', 'job' : 'painter' , 'age' : 30}print(a.get('name'))print(a.get('dinner'))print(a.get('dinner', 'empty')) cheis None empty if조건문12345678910a = -5if a &gt; 5 : print('a ids bigger than 5')elif a &gt; 0 : print(&quot;a is bigger than 0 but a is smaller than 5&quot;)else : print(&quot;a is negative&quot;) a is negative 반복문12for i in range(5) : # 5번 반복 print(&quot;hello World&quot;) hello World hello World hello World hello World hello World 1234567a = &quot;Kaggle&quot;for x in a : # a의 열을 하나씩 반복 print(x) if x == 'g' : #g 나오면 브레이크 break K a g","link":"/2021/11/02/temp211101/"},{"title":"if 중첩문 사용하기","text":"중첩문에 대해 알아보자 123456789x = 15if x &gt;=15 : print('10이상입니다.') if x == 15 : print('15입니다') if x == 20 : print('20입니다.') 10이상입니다. 15입니다 이렇게 들여쓰기가 된 if x == 15 : 와 if x == 20 : 은 처음에 나온 if X &gt;=10 : 에 속한 코드입니다.즉, if x &gt;=10 : 의 조건식이 만족해야 실행하는 코드 사용자가 입력한 값에 if 조건문 사용하기input을 사용하여 사용자가 입력한 값을 변수에 저장하고, if 조건문으로 값을 비교해보자. 12345678x =int(input()) print('당신이 입력한 숫자는',x, '입니다.')if x == 10 : print('10 입니다.')if x == 20 : print('20 입니다,') 10 당신이 입력한 숫자는 10 입니다. 10입니다. 입력 값이 x에 저장되고 if로 x가 10인지 비교한다.여기서는 10을 입력했으므로 ‘10입니다.’가 출력됩니다.","link":"/2021/11/02/temp211102/"},{"title":"python pandas 정리","text":"판다스는 파이썬에서 데이터 처리를 위해 존재하는 가장 인기 있는 라이브러리이다. 일반적으로 대부분의 데이터 세트는 2차원 데이터입니다. 행(Row) X **열(column)**로 구성되어 있다. 판다스의 핵심객체는 DataFrame.여러 개의 행가 열로 이뤄진 2차원 데이터를 담는 데이터 구조체이다. 라이브러리 불러오기 12import pandas as pdprint(pd.__version__) 1.1.5 테스트 12df = pd.DataFrame({'col1':[1,2],'col2': [3,4]})print(type(df)) &lt;class 'pandas.core.frame.DataFrame'&gt; 구글 드라이브 연동 12from google.colab import drivedrive.mount('/content/drive') Mounted at /content/drive 12345# DATA_PATH = '경로를 입력하세요'# 경로는 다음과 같이 설정한다.DATA_PATH = '/content/drive/MyDrive/Colab Notebooks/lectures_210923/PART_I_Intro/data/Lemonade2016.csv'lemonade = pd.read_csv(DATA_PATH)lemonade.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 32 entries, 0 to 31 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Date 31 non-null object 1 Location 32 non-null object 2 Lemon 32 non-null int64 3 Orange 32 non-null int64 4 Temperature 32 non-null int64 5 Leaflets 31 non-null float64 6 Price 32 non-null float64 dtypes: float64(2), int64(3), object(2) memory usage: 1.9+ KB 데이터 불러오기12lemonade.head(5)#앞에서부터 5개의 데이터 값을 불러온다 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price 0 7/1/2016 Park 97 67 70 90.0 0.25 1 7/2/2016 Park 98 67 72 90.0 0.25 2 7/3/2016 Park 110 77 71 104.0 0.25 3 7/4/2016 Beach 134 99 76 98.0 0.25 4 7/5/2016 Beach 159 118 78 135.0 0.25 12lemonade.tail(3)#뒤에서부터 3개의 데이터 값을 불러온다 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price 29 7/29/2016 Park 100 66 81 95.0 0.35 30 7/30/2016 Beach 88 57 82 81.0 0.35 31 7/31/2016 Beach 76 47 82 68.0 0.35 12print(lemonade.info())#데이터 정보를 출력한다. &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 32 entries, 0 to 31 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Date 31 non-null object 1 Location 32 non-null object 2 Lemon 32 non-null int64 3 Orange 32 non-null int64 4 Temperature 32 non-null int64 5 Leaflets 31 non-null float64 6 Price 32 non-null float64 dtypes: float64(2), int64(3), object(2) memory usage: 1.9+ KB None 12lemonade.describe()# describe() 함수를 사용하면 수치형 변수만을 기준으로 카운트, 평균, 표준편차, 최소/최대값, 4분의 수를 기준으로 25%, 50%, 75% 에 해당하는 값들을 테이블로 출력한다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Lemon Orange Temperature Leaflets Price count 32.000000 32.000000 32.000000 31.000000 32.000000 mean 116.156250 80.000000 78.968750 108.548387 0.354687 std 25.823357 21.863211 4.067847 20.117718 0.113137 min 71.000000 42.000000 70.000000 68.000000 0.250000 25% 98.000000 66.750000 77.000000 90.000000 0.250000 50% 113.500000 76.500000 80.500000 108.000000 0.350000 75% 131.750000 95.000000 82.000000 124.000000 0.500000 max 176.000000 129.000000 84.000000 158.000000 0.500000 count 행 내에 null(빈값, numpy의 NaN과 같은 취급)이 아닌 row의 개수를 센다. mean 모든 row에 있어 각 colum들의 값에 대한 평균값을 나타낸다. null값은 아예 없는 값으로 취급하여 분모에 들어가지 않는다. 즉 sum(모든 row의 값)/count 가 된다고 생각하면 된다. std 해당 column들의 값을에 대한 표준편차를 나타낸다. 역시 null값은 없는 값으로 취급한다. min, 25%, 50%, 75%, max 해당 column들의 값 중 최솟값, 사분위수, 최대값을 의미한다. 12lemonade['Location'].value_counts()해당열의 정보 갯수를 나타낸다. Beach 17 Park 15 Name: Location, dtype: int64 데이터 다뤄보기123lemonade['Sold'] = 0print(lemonade.head(3))#데이터에 sold 행을 추가함 Date Location Lemon Orange Temperature Leaflets Price sold Sold 0 7/1/2016 Park 97 67 70 90.0 0.25 0 0 1 7/2/2016 Park 98 67 72 90.0 0.25 0 0 2 7/3/2016 Park 110 77 71 104.0 0.25 0 0 123lemonade['Sold'] = lemonade['Lemon'] + lemonade['Orange']print(lemonade.head(3))# sold 행에 데이터 값을 지정함. (레몬과 오렌지 값을 더한 값) Date Location Lemon Orange Temperature Leaflets Price sold Sold 0 7/1/2016 Park 97 67 70 90.0 0.25 0 164 1 7/2/2016 Park 98 67 72 90.0 0.25 0 165 2 7/3/2016 Park 110 77 71 104.0 0.25 0 187 123lemonade['Revenue'] = lemonade['Price'] * lemonade['Sold']print(lemonade.head(3))# 새 행을 추가함과 동시에 값을 지정해줌. Date Location Lemon Orange ... Price sold Sold Revenue 0 7/1/2016 Park 97 67 ... 0.25 0 164 41.00 1 7/2/2016 Park 98 67 ... 0.25 0 165 41.25 2 7/3/2016 Park 110 77 ... 0.25 0 187 46.75 [3 rows x 10 columns] 12345pd.set_option('display.max_columns', None)lemonade['Revenue'] = lemonade['Price'] * lemonade['Sold']print(lemonade.head(3)) Date Location Lemon Orange Temperature Leaflets Price sold Sold \\ 0 7/1/2016 Park 97 67 70 90.0 0.25 0 164 1 7/2/2016 Park 98 67 72 90.0 0.25 0 165 2 7/3/2016 Park 110 77 71 104.0 0.25 0 187 Revenue 0 41.00 1 41.25 2 46.75 1234pd.set_option('display.max_columns', 0)lemonade['Revenue'] = lemonade['Price'] * lemonade['Sold']print(lemonade.head(3)) Date Location Lemon Orange ... Price sold Sold Revenue 0 7/1/2016 Park 97 67 ... 0.25 0 164 41.00 1 7/2/2016 Park 98 67 ... 0.25 0 165 41.25 2 7/3/2016 Park 110 77 ... 0.25 0 187 46.75 [3 rows x 10 columns] 12lemonade_column_drop = lemonade.drop('Sold', axis=1)print(lemonade_column_drop.head(3)) Date Location Lemon Orange ... Leaflets Price sold Revenue 0 7/1/2016 Park 97 67 ... 90.0 0.25 0 41.00 1 7/2/2016 Park 98 67 ... 90.0 0.25 0 41.25 2 7/3/2016 Park 110 77 ... 104.0 0.25 0 46.75 [3 rows x 9 columns] 12lemonade_row_drop = lemonade_column_drop.drop(0, axis=0)print(lemonade_row_drop.head(3)) Date Location Lemon Orange ... Leaflets Price sold Revenue 1 7/2/2016 Park 98 67 ... 90.0 0.25 0 41.25 2 7/3/2016 Park 110 77 ... 104.0 0.25 0 46.75 3 7/4/2016 Beach 134 99 ... 98.0 0.25 0 58.25 [3 rows x 9 columns] 데이터 인덱싱12print(lemonade[0:5])# 0부터 5개의 값을 가져옴 Date Location Lemon Orange ... Price sold Sold Revenue 0 7/1/2016 Park 97 67 ... 0.25 0 164 41.00 1 7/2/2016 Park 98 67 ... 0.25 0 165 41.25 2 7/3/2016 Park 110 77 ... 0.25 0 187 46.75 3 7/4/2016 Beach 134 99 ... 0.25 0 233 58.25 4 7/5/2016 Beach 159 118 ... 0.25 0 277 69.25 [5 rows x 10 columns] 1lemonade['Location'] == 'Beach' 0 False 1 False 2 False 3 True 4 True 5 True 6 True 7 True 8 True 9 True 10 True 11 True 12 True 13 True 14 True 15 True 16 True 17 True 18 False 19 False 20 False 21 False 22 False 23 False 24 False 25 False 26 False 27 False 28 False 29 False 30 True 31 True Name: Location, dtype: bool 12print(lemonade[lemonade['Location']=='Beach'].head(3)) # Beach인 데이터를 앞에서 3개 출력한다. Date Location Lemon Orange ... Price sold Sold Revenue 3 7/4/2016 Beach 134 99 ... 0.25 0 233 58.25 4 7/5/2016 Beach 159 118 ... 0.25 0 277 69.25 5 7/6/2016 Beach 103 69 ... 0.25 0 172 43.00 [3 rows x 10 columns] 12print(lemonade.iloc[0:3,0:2])# 0 부터 3개의 열 / 0부터 2개의 행을 출력한다 Date Location 0 7/1/2016 Park 1 7/2/2016 Park 2 7/3/2016 Park 12print(lemonade.loc[0:2,['Date','Location']])# 0부터 2개의 열 / date와 location 의 값을 출력한다. Date Location 0 7/1/2016 Park 1 7/2/2016 Park 2 7/3/2016 Park 기본 데이터 전처리1print(lemonade.sort_values(by=['Temperature']).head(5)) Date Location Lemon Orange ... Price sold Sold Revenue 0 7/1/2016 Park 97 67 ... 0.25 0 164 41.00 20 7/20/2016 Park 71 42 ... 0.50 0 113 56.50 2 7/3/2016 Park 110 77 ... 0.25 0 187 46.75 1 7/2/2016 Park 98 67 ... 0.25 0 165 41.25 16 7/16/2016 Beach 81 50 ... 0.50 0 131 65.50 [5 rows x 10 columns] 12lemonade.sort_values(by=['Temperature','Revenue'], ascending = False, inplace = True)print(lemonade.loc[:,['Date','Temperature','Revenue']].head(5)) Date Temperature Revenue 25 7/25/2016 84 134.50 12 7/12/2016 84 56.25 26 7/26/2016 83 106.75 11 7/11/2016 83 70.50 24 7/24/2016 82 101.50 1print(lemonade.groupby(by='Location').count()) Date Lemon Orange Temperature ... Price sold Sold Revenue Location ... Beach 16 17 17 17 ... 17 17 17 17 Park 15 15 15 15 ... 15 15 15 15 [2 rows x 9 columns] 1print(lemonade.groupby('Location')['Revenue'].agg([max,min])) max min Location Beach 95.5 43.0 Park 134.5 41.0 1print(lemonade.groupby('Location')[['Revenue','Sold']].agg([max,min])) Revenue Sold max min max min Location Beach 95.5 43.0 282 123 Park 134.5 41.0 305 113","link":"/2021/11/02/pandas_basic/"},{"title":"python numpy 정리","text":"라이브러리 불러오기 12import numpy as npprint(np.__version__) 1.19.5 12temp = np.array([1,2,3])print(type(temp)) &lt;class 'numpy.ndarray'&gt; Numpy 배열 생성 및 둘러보기12data1 = [1,2,3]data1 [1, 2, 3] 12data2 = [1,1,2,2,3,4]data2 [1, 1, 2, 2, 3, 4] 123my_array1 = np.array(data1)print(my_array1)print(my_array1.shape) [1 2 3] (3,) 123my_array2 = np.array(data2)print(my_array2)print(my_array2.shape) [1 1 2 2 3 4] (6,) 1234my_array3 = np.array([3,6,9,12])print(my_array3)print(my_array3.shape)print(my_array3.dtype) [ 3 6 9 12] (4,) int64 12my_array4 = np.array([[2,4,6],[8,10,12],[14,16,18],[20,22,24]])my_array4 (4, 3) 12my_array4.shape# 4행과 3열 (4, 3) 12my_array5=np.array([[ [1,2] ,[3,4] ], [ [5,6] , [7,8] ]])my_array5.shape (2, 2, 2) Numpy 기본 함수##arangearrang()는 함수 이름에서 알수 있듯이 파이썬 표준 함수인 range()와 유사한 기능을 합니다. 쉽게 생각하면 array를 range()로 표현하는 것입니다. 0부터 함수 인자 값 -1까지의 값을 순차적으로 ndarray의 데이터 값으로 변화해 줍니다. 12arrange_array = np.arange(5)arrange_array array([0, 1, 2, 3, 4]) 12arrange_array2 =np.arange(1,9,3)arrange_array2 array([1, 4, 7]) zeroes, ones1234zeroes_array = np.zeros((3,2))print(zeroes_array)print(&quot;Data Type is : &quot;, zeroes_array.dtype)print(&quot;Data Type is : &quot; , zeroes_array.shape) [[0. 0.] [0. 0.] [0. 0.]] Data Type is : float64 Data Type is : (3, 2) 1234ones_array = np.ones((3,4), dtype='int32')print(ones_array)print(&quot;Data Type is : &quot; , ones_array.dtype)print(&quot;Data Type is : &quot;, ones_array.shape) [[1 1 1 1] [1 1 1 1] [1 1 1 1]] Data Type is : int32 Data Type is : (3, 4) ##reshapereshape() 메서드는 ndarray를 특정 차원 및 크기로 변환합니다. 변환을 원하는 크기를 함수 인자로 부여하면 됩니다. 1234after_reshape = ones_array.reshape(6,2)print(after_reshape)print(&quot;Data Shape is&quot; , after_reshape.shape)# 단 6*2의 값과 같은 크기로 변환이 가능하다 EX) (1,12), (2,3,2) etc... [[1 1] [1 1] [1 1] [1 1] [1 1] [1 1]] Data Shape is (6, 2) 123after_reshape = ones_array.reshape(2,3,2)print(after_reshape)print(&quot;Data Shape is&quot; , after_reshape.shape) [[[1 1] [1 1] [1 1]] [[1 1] [1 1] [1 1]]] Data Shape is (2, 3, 2) 1234after_reshape3 = ones_array.reshape(3,-1)print(&quot;reshape(3,-1)? \\n&quot;)print(after_reshape3)print(&quot;Data Shape is : &quot; , after_reshape3.shape) reshape(3,-1)? [[1 1 1 1] [1 1 1 1] [1 1 1 1]] Data Shape is : (3, 4)","link":"/2021/11/02/Numpy_basic/"},{"title":"SQL &#x2F; 데이터 모델링의 이해","text":"데이터 모델링의 이해데이터 모델의 이해데이터 모델정보 시스템을 구축하기 위한 데이터 관점의 업무분석기법 현실 데이터에 대한 약속된 표기법에 의한 표현하는 과정 DB를 구축하기 위한 분석과 설계의 과정 모델링의 특징현실 세계를 일정한 형식에 맞추어 표현하는 추상화의 의미 시스템 구현, 업무분석, 업무 형상화의 목적 복잡한 현실을 제한된 언어나 표기법으로 이해하기 쉽도록 단순화 모함을 배제 > 누구나 이해가능하도록 현상기술하는 정확함 모델링 자체로 업무 설명과 분석하느 부분에서 의미를 가짐 모델링의 유의사항중복성 : 여러장소에 중복테이더 저장X 비유연성 : 데이터의 정의와 사용 프로레스 분리 / 데이터나 프로세스의 변화가 앱과 DB에 변화를 일으킬 가능성 비일관성 : 중복성 없어도 비일관성 발생가능 / 데이터와 그것들의 상호관계가 명확하게 정의 / 사용자 처리 프로세스 OR 관련프로그램과 테이블의 연계성을 높임 >데이터 모델이 업무변경에 대해 취약하게 만드는 단점 데이터 모델 개념개념적 : 추상화, 업무중심 + 포괄적인 수준의 모델링, 전사적 모델링, EA 수립시 사용 논리적 : 시스템으로 구축하고자 하는 업무에 대해 key 속성, 관계들을 정화하게 표현, 재사용성이 높다 물리적 : 실제 데이더베이스에 이식 할 수 있도록 성능, 저장 등 물리적 성격을 고려해 설계","link":"/2021/11/03/SQLD(212203)/"},{"title":"python Visualization","text":"Matplotlibmatplotlib.pyplot / 각 pyplot()함수는 figure를 변형시킨다. 예를들어 figure생성, figure에 플롯 영역 생성, 플롯영역에 일부 선그리기, 레이블로 플롯 꾸미기 등이 있다. pyplot는 시각화를 매우 빠르게 만들 수있다. 1234567891011121314151617import matplotlib.pyplot as pltdates = [ '2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05' ,'2021-01-06', '2021-01-07' ,'2021-01-08', '2021-01-09', '2021-01-10']min_temperature = [20.7,17.9,18.8,14.6,15.8,15.8,15.8,17.4,21.8,20.0]max_temperature = [34.7,28.9,31.8,25.6,28.8,21.8,22.8,28.4,30.8,32.0]fig, ax = plt.subplots()ax. plot(dates, min_temperature, label = 'Min Temp')ax. plot(dates, max_temperature, label = 'Max Temp')ax.legend()plt.show &lt;function matplotlib.pyplot.show&gt; 선 그래프12!pip install yfinance --upgrade --no-cache-dir#데이터를 다운받음 1234import yfinance as yfdata = yf.download('AAPL','2019-08-01','2020-08-01')data.info()#다운받은 데이터의 정보를 볼러온다. [*********************100%***********************] 1 of 1 completed &lt;class 'pandas.core.frame.DataFrame'&gt; DatetimeIndex: 253 entries, 2019-08-01 to 2020-07-31 Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Open 253 non-null float64 1 High 253 non-null float64 2 Low 253 non-null float64 3 Close 253 non-null float64 4 Adj Close 253 non-null float64 5 Volume 253 non-null int64 dtypes: float64(5), int64(1) memory usage: 13.8 KB 12ts = data['Open']print(ts.head()) Date 2019-08-01 53.474998 2019-08-02 51.382500 2019-08-05 49.497501 2019-08-06 49.077499 2019-08-07 48.852501 Name: Open, dtype: float64 PyPlot API + 객체지향 API1234567891011121314#import fix_yahoo_finance as yfimport yfinance as yfimport matplotlib.pyplot as pltdata = yf.download('AAPL','2019-08-01','2020-08-01')ts = data['Open']fig, ax = plt.subplots(figsize=(10,6))# 직접 Figure 객체 생성# ax = fig.subplots() # 직접 axes를 생성ax.plot(ts) #생성된 axes에 대한 plot() 멤버 직접 호출ax.set_title('Stock Market fluctuation of AAPL')ax.legend(labels=['Price'],loc='best')ax.set_xlabel('Data')ax.set_ylabel('Stock Market Open Price')plt.show() [*********************100%***********************] 1 of 1 completed 막대그래프1234567891011121314151617181920import matplotlib.pyplot as plt import numpy as np #Numpyimport calendar #해당월 의 달력 출력하기month_list = [1,2,3,4,5,6,7,8,9,10,11,12]sold_list = [300,400,550,900,600,960,900,910,800,700,550,450]fig, ax = plt.subplots(figsize=(10,6))# fig = figure : 데이터가 담기는 프레임, 크기, 모양을 변형할수 있지만 실제로 프레임 위에 글씨를 쓸수 없다. 즉 여러 그래프가 담길 수 있는 액자 같은 역활을 한다.# ax = axes : 실제 데이터가 그려지는 캔버스. 그렇기에 모든 plot은 axes위에서 이루어져야 하는 것이다.plt.xticks(month_list, calendar.month_name[1:13], rotation=90)plot = ax.bar(month_list, sold_list)for rect in plot: print(&quot;graph : &quot;,rect) height = rect.get_height() ax.text(rect.get_x() + rect.get_width()/2.,1.002*height,'%d' % int(height), ha='center', va='bottom') plt.show graph : Rectangle(xy=(0.6, 0), width=0.8, height=300, angle=0) graph : Rectangle(xy=(1.6, 0), width=0.8, height=400, angle=0) graph : Rectangle(xy=(2.6, 0), width=0.8, height=550, angle=0) graph : Rectangle(xy=(3.6, 0), width=0.8, height=900, angle=0) graph : Rectangle(xy=(4.6, 0), width=0.8, height=600, angle=0) graph : Rectangle(xy=(5.6, 0), width=0.8, height=960, angle=0) graph : Rectangle(xy=(6.6, 0), width=0.8, height=900, angle=0) graph : Rectangle(xy=(7.6, 0), width=0.8, height=910, angle=0) graph : Rectangle(xy=(8.6, 0), width=0.8, height=800, angle=0) graph : Rectangle(xy=(9.6, 0), width=0.8, height=700, angle=0) graph : Rectangle(xy=(10.6, 0), width=0.8, height=550, angle=0) graph : Rectangle(xy=(11.6, 0), width=0.8, height=450, angle=0) ###산점도 그래프 두개의 연속현 변수(키, 몸무게 등) 상관관계 != 인과관계 123456789101112131415import matplotlib.pyplot as pltimport seaborn as sns#내장 데이터tips = sns.load_dataset(&quot;tips&quot;)x = tips['total_bill']y = tips['tip']fig, ax = plt.subplots(figsize=(10,6))ax.scatter(x,y)ax.set_xlabel('Total Bill')ax.set_ylabel('Tip')ax.set_title('Tip ~Total Bill')fig.show() 1label, data = tips.groupby('sex') 1234567891011tips['sex_color'] = tips['sex'].map({&quot;Female&quot; : &quot;#0000FF&quot;, &quot;Male&quot; : &quot;#00FF00&quot; })fig,ax = plt.subplots(figsize=(10,6))for label, data in tips.groupby('sex'): ax.scatter(data['total_bill'], data['tip'], label=label, color=data['sex_color'], alpha=0.5) ax.set_xlabel('Total Bill') ax.set_ylabel('Tip') ax.set_title('Tip ~ Total Bill by Gender')ax.legend()fig.show &lt;bound method Figure.show of &lt;Figure size 720x432 with 1 Axes&gt;&gt; 박스플롯 X축 변수 : 범주형 변수, 그룹과 관련있는 변수, 문자열 y축 변수 : 수치형 변수 12345678910111213141516import matplotlib.pyplot as pltimport seaborn as snsiris = sns.load_dataset('iris')data = [iris[iris['species']==&quot;setosa&quot;]['petal_width'], iris[iris['species']==&quot;versicolor&quot;]['petal_width'], iris[iris['species']==&quot;virginica&quot;]['petal_width']]fig, ax = plt.subplots(figsize=(10,6))ax.boxplot(data, labels=['setosa','versicolor','virginica'])fig.show &lt;bound method Figure.show of &lt;Figure size 720x432 with 1 Axes&gt;&gt;","link":"/2021/11/03/python_visualization/"},{"title":"boxplot","text":"박스플롯이란??출처 : https://dschloe.github.io/python/python_edu/03_datavisualisation/ch_boxplot/ 박스플롯 그래프박스플롯 그래프는 범주형 데이터 기준으로 수치형 데이터의 분포를 파악하는데 적합하다. 박스플롯을 보면 최솟값, 1분위, 중간값, 3분위 값, 최대값을 제공한다. 1)라이브러리 불러오기필요한 모듈을 불러온다. 2)데이터 생성seaborn 패키지 내 iris 데이터를 활용한다. 12345import matplotlib.pyplot as pltimport numpy as np import seaborn as snsiris = sns.load_dataset('iris')iris .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } sepal_length sepal_width petal_length petal_width species 0 5.1 3.5 1.4 0.2 setosa 1 4.9 3.0 1.4 0.2 setosa 2 4.7 3.2 1.3 0.2 setosa 3 4.6 3.1 1.5 0.2 setosa 4 5.0 3.6 1.4 0.2 setosa ... ... ... ... ... ... 145 6.7 3.0 5.2 2.3 virginica 146 6.3 2.5 5.0 1.9 virginica 147 6.5 3.0 5.2 2.0 virginica 148 6.2 3.4 5.4 2.3 virginica 149 5.9 3.0 5.1 1.8 virginica 150 rows × 5 columns 12#위 데이터에서 species 변수 내 데이터를 확인해보자.iris['species'].unique() array(['setosa', 'versicolor', 'virginica'], dtype=object) 박스플롯으로 그래프를 구현할 때에는 위 3개의 데이터를 List 안에 담아야 한다. 123data = [iris[iris['species']==&quot;setosa&quot;]['sepal_length'], iris[iris['species']==&quot;versicolor&quot;]['sepal_length'], iris[iris['species']==&quot;virginica&quot;]['sepal_length']] 3) 그래프 구현각각의 데이터를 기준으로 박스플롯을 작성한다. 데이터의 평균을 표시하는 showmeans를 추가해 본다. 123plt.boxplot(data, labels=['setosa','versicolor','virginica'],showmeans = True)plt.show &lt;function matplotlib.pyplot.show&gt; 1이번에는 옵션 vert=False 를 추가한다. 12plt.boxplot(data, labels=['setosa', 'versicolor', 'virginica'], showmeans=True, vert = False)plt.show()","link":"/2021/11/03/BoxPlot/"},{"title":"Yfinance_laod","text":"한 종목 주가 데이터 받아오기 (삼성전자)12!pip install yfinance --upgrade --no-cache-dir#데이터를 다운받음 12345678#블로그에 올라온 자료import pandas as pdimport yfinance as yf # yfinance 를 임포트 한다.tic = '005930.KS' #삼성전자df = yf.download(tic, start='2020-01-01', end='2020-12-31',progress=False)df.info()#tic에 받고자 하는 종목 정보를 넣는다 &lt;class 'pandas.core.frame.DataFrame'&gt; DatetimeIndex: 248 entries, 2020-01-02 to 2020-12-30 Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Open 248 non-null float64 1 High 248 non-null float64 2 Low 248 non-null float64 3 Close 248 non-null float64 4 Adj Close 248 non-null float64 5 Volume 248 non-null int64 dtypes: float64(5), int64(1) memory usage: 13.6 KB 1df.head(5) # 5개의 정보를 불러왔다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Open High Low Close Adj Close Volume Date 2020-01-02 55500.0 56000.0 55000.0 55200.0 52058.132812 12993228 2020-01-03 56000.0 56600.0 54900.0 55500.0 52341.058594 15422255 2020-01-06 54900.0 55600.0 54600.0 55500.0 52341.058594 10278951 2020-01-07 55700.0 56400.0 55600.0 55800.0 52623.980469 10009778 2020-01-08 56200.0 57400.0 55900.0 56800.0 53567.058594 23501171 123456789101112131415#import fix_yahoo_finance as yfimport yfinance as yfimport matplotlib.pyplot as plttic = '005930.KS' #삼성전자df = yf.download(tic, start='2020-01-01', end='2021-11-01',progress=False)ts1 = df['Open']fig, ax = plt.subplots(figsize=(10,6))# 직접 Figure 객체 생성# ax = fig.subplots() # 직접 axes를 생성ax.plot(ts1) #생성된 axes에 대한 plot() 멤버 직접 호출ax.set_title('Stock Market fluctuation of Samsung Electronics')ax.legend(labels=['Price'],loc='best')ax.set_xlabel('Data')ax.set_ylabel('Stock Market Open Price')plt.show() 12345# 수업시간에 했던 자료import yfinance as yfdata = yf.download('AAPL','2019-08-01','2020-08-01')data.info()#다운받은 데이터의 정보를 볼러온다. [*********************100%***********************] 1 of 1 completed &lt;class 'pandas.core.frame.DataFrame'&gt; DatetimeIndex: 253 entries, 2019-08-01 to 2020-07-31 Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Open 253 non-null float64 1 High 253 non-null float64 2 Low 253 non-null float64 3 Close 253 non-null float64 4 Adj Close 253 non-null float64 5 Volume 253 non-null int64 dtypes: float64(5), int64(1) memory usage: 13.8 KB","link":"/2021/11/04/yfinance_load/"},{"title":"Decision Tree","text":"결정트리(Decision Tree)분류와 회귀에 사용되는 지도학습 방법 데이터 특성으로부터 추론된 결정 규칙을 통해 값을 예측 if-then-else 결정규칙을 통해 데이터 학습 트리의 깊이가 깊을 수록 복잡한 모델 결정 트리 장점 1.이해와 해석이 쉽다. 2.시각화가 용이하다 3,많은 데이터 전처리가 필요하지 않다. 4.수치형과 범주형 데이터 모두를 다룰수 있다. 단점 데이터를 잘 일반화하지 못하고 복잡한 트리를 만들 수 있다. 1번과 같은 것을 과적합이라고 하며, 알고리즘 성능이 떨어진다.이를 극복하기 위해 트리의 크기를 사전에 제한하는 튜닝이 필요하다. 사이킷런은 결정트리 알고리즘을 구현한 DecisionTreeClassifier 와DecisionTreeRegressor클래스를 제공한다. DecisionTreeClassifier는 분류를 위한 클래스이며, DecisionTreeRegressor 는 회귀를 위한 클래스이다. ##DecisionTreeClassifier분류를 위한 클래스를 알아보자. 12345from sklearn import treeX = [[0,0],[1,1]]Y = [0,1]clf = tree.DecisionTreeClassifier()clf = clf.fit(X, Y) 모델을 사용하여 표본의 클래스를 예측할 수 있다. 1clf.predict([[2.,2.]]) array([1]) 결정트리 분류 클래스는 이진[-1,1]분류와 다중 클래스 (라벨이[0,…,k-1]인경우)분류를 모두 수행할 수 있다. 1clf.predict_proba([[2.,2.]]) array([[0., 1.]]) iris 데이터를 활용하여 다음과 같이 트리를 구성할수 있다. 123456from sklearn.datasets import load_irisfrom sklearn import treeiris = load_iris()X, y = iris.data, iris.targetclf = tree.DecisionTreeClassifier()clf = clf.fit(X,y) 12tree.plot_tree(clf)[...] [Ellipsis] 이를 export_graphviz를 활용하여 결정트리 알고리즘이 어떠한 규칙을 가지고 트리를 생성하는지 시각적으로 보여줄 수 있다. 1234import graphvizdot_data = tree.export_graphviz(clf, out_file=None)graph = graphviz.Source(dot_data)graph.render(&quot;iris&quot;) 'iris.pdf' 1234567dot_data = tree.export_graphviz(clf, out_file=None, feature_names=iris.feature_names, class_names=iris.target_names, filled=True, rounded=True, special_characters=True)graph = graphviz.Source(dot_data)graph","link":"/2021/11/04/Decision_Tree(%EA%B2%B0%EC%A0%95%ED%8A%B8%EB%A6%AC)/"}],"tags":[{"name":"python","slug":"python","link":"/tags/python/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"SQLD","slug":"SQLD","link":"/tags/SQLD/"},{"name":"Visualization","slug":"Visualization","link":"/tags/Visualization/"},{"name":"boxplot","slug":"boxplot","link":"/tags/boxplot/"},{"name":"Yfinance","slug":"Yfinance","link":"/tags/Yfinance/"},{"name":"Decision Tree","slug":"Decision-Tree","link":"/tags/Decision-Tree/"}],"categories":[{"name":"python","slug":"python","link":"/categories/python/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"Entity","slug":"SQL/Entity","link":"/categories/SQL/Entity/"},{"name":"Visualization","slug":"python/Visualization","link":"/categories/python/Visualization/"},{"name":"boxplot","slug":"python/boxplot","link":"/categories/python/boxplot/"},{"name":"Yfinance","slug":"python/Yfinance","link":"/categories/python/Yfinance/"},{"name":"Decision Tree","slug":"python/Decision-Tree","link":"/categories/python/Decision-Tree/"}]}