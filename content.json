{"pages":[],"posts":[{"title":"python 기본 문법","text":"1print(&quot;hello, World&quot;) hello, World 주석처리12345# 한줄 주석처리&quot;&quot;&quot;여러 줄 주석 예제 동일한 따옴표(큰 따옴표 혹은 작은 따옴 표) 세 개와 세개 사이는 어떤 내용이 들어가도 주석처리가 된다.&quot;&quot;&quot;print(&quot;Hello&quot;) Hello 변수의 종류12num_int = 1print(type(num_int)) &lt;class 'int'&gt; 12num_float = 0.2print(type(num_float)) &lt;class 'float'&gt; 12bool_true = Trueprint(type(bool_true)) &lt;class 'bool'&gt; 12none_x = Noneprint(type(none_x)) &lt;class 'NoneType'&gt; 논리형 &amp; 비교 연산자 응용12345num1 = int(input(&quot;첫번째 번호 입력&quot;))num2 = int(input(&quot;두번째 번호 입력&quot;))var1 = num1 &gt;= num2print(var1) 첫번째 번호 입력2 두번째 번호 입력2 True String Operators123str1 = &quot;hello &quot;str2 = &quot;world &quot;print(&quot;str1 + str2 = &quot;, str1 + str2) str1 + str2 = hello world 12greet = str1 + str2print('greet * 5 = ', greet *5) greet * 5 = hello world hello world hello world hello world hello world Indexing1234567greeting = &quot;hello Kaggle&quot;print(greeting[:]) # 전체print(greeting[0]) # 0값을 가져옴print(greeting[6:]) # 6부터 끝까지print(greeting[:6]) # 0부터 6까지print(greeting[3:8]) # 3부터 8까지 가져옴print(greeting[0:9:2]) #0부터 9까지 가져오면서 2칸씩 띄우고 가져옴 hello Kaggle h Kaggle hello lo Ka hloKg 리스트123456789a = [] # 빈리스트a_func = list() #list() 함수로도 빈 리스트를 만들 수 있다.b = [1] # 숫자도 요소가 될 수 있다.c = ['apple'] # 문자열도 요소가 될 수 있다.d = [1,2,['apple']] #리스트 안에 리스트를 요소로 넣을 수있다.print(a)print(b)print(c)print(d) [] [1] ['apple'] [1, 2, ['apple']] 123456a = [1, 2, 3]# index [0,1,2]print(a[0]) #첫번째 요소print(a[1]) # 두번째 요소print(a[2]) # 세번째 요소print(a[-1]) 1 2 3 3 123456a = [['apple','banana','cherry']]print(a[0])print(a[0][0]) # 0의 0 인덱스 값print(a[0][0][3]) # 리스트 내의 리스트의 첫번째 문자열 'apple' 중 세번째 인덱스print(a[0][2]) ['apple', 'banana', 'cherry'] apple l cherry 123456789a = [1,2,3,4,5,6,7,8,9,10]b = a[:4] # 인덱스 0부터 3까지c = a[1:4] #인덱스 1부터 3까지d = a[0:7:2] #인덱스 0부터 6까지 인덱스 2칸 건너 띄우기f = a[::2] #리스트 전체구간에서 인덱스 2씩 건너띄우기print(&quot;a[:4] : &quot;,b)print(&quot;a[1:4] : &quot;,c)print(&quot;a[0:7:2] : &quot; , d)print(&quot;a[::2] : &quot;, f) a[:4] : [1, 2, 3, 4] a[1:4] : [2, 3, 4] a[0:7:2] : [1, 3, 5, 7] a[::2] : [1, 3, 5, 7, 9] 12345a = ['alice','bob','cat']b = ['apple','banana','cherry']c = a+bprint(c) ['alice', 'bob', 'cat', 'apple', 'banana', 'cherry'] 리스트 값 수정하기1234a = [0,1,2]a[1] = &quot;b&quot; # 인덱스 1열 수정print(a) [0, 'b', 2] 리스트 값 추가하기123456a = [100,200,300]a.append(400)print(a)a.append([500,600])print(a) [100, 200, 300, 400] [100, 200, 300, 400, [500, 600]] 1234a = [1,2,3]a.extend([40,500])print('a.extend([40,500])result')print(a) a.extend([40,500])result [1, 2, 3, 40, 500] 123456789101112131415a = [0,1,2,3]a[2:2] = [100,200]print(a)# 시작과 끝의 범위 보다 큰 수를 덮어쓰는 예시b = [0,1,2,3]b[1:2] = [100,200,300,400]# 1행에서 1행까지 덮어쓰기print(b)# 시작과 끝의 범위가 작을때의 예시c = [0,1,2,3]c[1:3] = [100] #1행에서 2행까지 덮어쓰기print(c) [0, 1, 100, 200, 2, 3] [0, 100, 200, 300, 400, 2, 3] [0, 100, 3] 리스트 값 삭제하기123456a = [1,2,1,2]#리스트의 첫번째 1이 삭제a.remove(1)print(a) [2, 1, 2] [2, 2] 12345678910a = [0,1,2,3,4,5,6,7,8,9]# 1 삭제del a[1]print(a)b = [0,1,2,3,4,5,6,7,8,9]# 범위로 삭제del b[1:3] #list는 항상 시작하는 인덱스부터 종료하는 n의 n-1까지의 범위를 잡아줍니다.print(b) [0, 2, 3, 4, 5, 6, 7, 8, 9] [0, 3, 4, 5, 6, 7, 8, 9] 123456#인덱스를 지정한 pop()a = [0,1,2,3,4]r = a.pop(1)print(a)print(r) [0, 2, 3, 4] 1 123456# 인덱스를 지정하지 않은 pop()b = ['a','b','c','d']x = b.pop()print(b)print(x) ['a', 'b', 'c'] d 그 외 유용한 메서드12345a = [0,1,2,3]print(a)a.clear()print(a) [0, 1, 2, 3] [] 12a = [&quot;gold&quot;,&quot;gold&quot;,&quot;silver&quot;,&quot;silver&quot;]print(&quot;sliver가 처음 등장하는 인덱스 번호 : &quot; ,a.index(&quot;silver&quot;)) sliver가 처음 등장하는 인덱스 번호 2 12345678a = [1,4,5,2,3]b = [1,4,5,2,3]a.sort()print(&quot;sort() : &quot; ,a) #오름차순b.sort(reverse=True)print(&quot;sort(reverse=True):&quot;,b) #내림차순 sort() : [1, 2, 3, 4, 5] sort(reverse=True): [5, 4, 3, 2, 1] 튜플1234567891011tuple1 =(0) #끝에 콤마(,)를 붙이지 않았을 때tuple2 = (0,) #끝에 콤마(,)를 붙여줬을 때tuple3 = 0,1,2print(tuple1)print(tuple2)print(tuple3)print(type(tuple1)) #콤마(,)를 붙여주지 않으면 튜플이 아닙니다.print(type(tuple2)) #콤마(,)를 붙여주어야 튜플 자료형입니다.print(type(tuple3)) #여러개의 값 일 경우 괄호를 없애주어도 튜플 자료형입니다. 0 (0,) (0, 1, 2) &lt;class 'int'&gt; &lt;class 'tuple'&gt; &lt;class 'tuple'&gt; 더하기 및 곱셈 연산자 사용12345t1 = (0,1,2,3,4)t2 = ('a','b','c')t3 = t1 +t2print(t1+t2)print(t3) (0, 1, 2, 3, 4, 'a', 'b', 'c') (0, 1, 2, 3, 4, 'a', 'b', 'c') 123t1 = ('a','b')print(t1 *0)print(t1 *3) () ('a', 'b', 'a', 'b', 'a', 'b') 딕셔너리1234dic = {'teacher' : &quot;alice&quot;,'class':5,'student' : 15,'list' : [1,2,3]}print(dic['teacher'])print(dic['class'])print(dic['list']) alice 5 [1, 2, 3] 12a = {'name' : 'bob' , 'job' : 'farmer', 'age' : 35}a.keys() #키워드를 찾아주는 메서드 dict_keys(['name', 'job', 'age']) 12a = {'name' : 'bob' , 'job' : 'farmer', 'age' : 35}a.values() #키워드의 정보를 찾아주는 메서드 dict_values(['bob', 'farmer', 35]) 1234a = {'name' : 'cheis', 'job' : 'painter' , 'age' : 30}print(a.get('name'))print(a.get('dinner'))print(a.get('dinner', 'empty')) cheis None empty if조건문12345678910a = -5if a &gt; 5 : print('a ids bigger than 5')elif a &gt; 0 : print(&quot;a is bigger than 0 but a is smaller than 5&quot;)else : print(&quot;a is negative&quot;) a is negative 반복문12for i in range(5) : # 5번 반복 print(&quot;hello World&quot;) hello World hello World hello World hello World hello World 1234567a = &quot;Kaggle&quot;for x in a : # a의 열을 하나씩 반복 print(x) if x == 'g' : #g 나오면 브레이크 break K a g","link":"/2021/11/02/temp211101/"},{"title":"if 중첩문 사용하기","text":"중첩문에 대해 알아보자 123456789x = 15if x &gt;=15 : print('10이상입니다.') if x == 15 : print('15입니다') if x == 20 : print('20입니다.') 10이상입니다. 15입니다 이렇게 들여쓰기가 된 if x == 15 : 와 if x == 20 : 은 처음에 나온 if X &gt;=10 : 에 속한 코드입니다.즉, if x &gt;=10 : 의 조건식이 만족해야 실행하는 코드 사용자가 입력한 값에 if 조건문 사용하기input을 사용하여 사용자가 입력한 값을 변수에 저장하고, if 조건문으로 값을 비교해보자. 12345678x =int(input()) print('당신이 입력한 숫자는',x, '입니다.')if x == 10 : print('10 입니다.')if x == 20 : print('20 입니다,') 10 당신이 입력한 숫자는 10 입니다. 10입니다. 입력 값이 x에 저장되고 if로 x가 10인지 비교한다.여기서는 10을 입력했으므로 ‘10입니다.’가 출력됩니다.","link":"/2021/11/02/temp211102/"},{"title":"python pandas 정리","text":"판다스는 파이썬에서 데이터 처리를 위해 존재하는 가장 인기 있는 라이브러리이다. 일반적으로 대부분의 데이터 세트는 2차원 데이터입니다. 행(Row) X **열(column)**로 구성되어 있다. 판다스의 핵심객체는 DataFrame.여러 개의 행가 열로 이뤄진 2차원 데이터를 담는 데이터 구조체이다. 라이브러리 불러오기 12import pandas as pdprint(pd.__version__) 1.1.5 테스트 12df = pd.DataFrame({'col1':[1,2],'col2': [3,4]})print(type(df)) &lt;class 'pandas.core.frame.DataFrame'&gt; 구글 드라이브 연동 12from google.colab import drivedrive.mount('/content/drive') Mounted at /content/drive 12345# DATA_PATH = '경로를 입력하세요'# 경로는 다음과 같이 설정한다.DATA_PATH = '/content/drive/MyDrive/Colab Notebooks/lectures_210923/PART_I_Intro/data/Lemonade2016.csv'lemonade = pd.read_csv(DATA_PATH)lemonade.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 32 entries, 0 to 31 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Date 31 non-null object 1 Location 32 non-null object 2 Lemon 32 non-null int64 3 Orange 32 non-null int64 4 Temperature 32 non-null int64 5 Leaflets 31 non-null float64 6 Price 32 non-null float64 dtypes: float64(2), int64(3), object(2) memory usage: 1.9+ KB 데이터 불러오기12lemonade.head(5)#앞에서부터 5개의 데이터 값을 불러온다 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price 0 7/1/2016 Park 97 67 70 90.0 0.25 1 7/2/2016 Park 98 67 72 90.0 0.25 2 7/3/2016 Park 110 77 71 104.0 0.25 3 7/4/2016 Beach 134 99 76 98.0 0.25 4 7/5/2016 Beach 159 118 78 135.0 0.25 12lemonade.tail(3)#뒤에서부터 3개의 데이터 값을 불러온다 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price 29 7/29/2016 Park 100 66 81 95.0 0.35 30 7/30/2016 Beach 88 57 82 81.0 0.35 31 7/31/2016 Beach 76 47 82 68.0 0.35 12print(lemonade.info())#데이터 정보를 출력한다. &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 32 entries, 0 to 31 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Date 31 non-null object 1 Location 32 non-null object 2 Lemon 32 non-null int64 3 Orange 32 non-null int64 4 Temperature 32 non-null int64 5 Leaflets 31 non-null float64 6 Price 32 non-null float64 dtypes: float64(2), int64(3), object(2) memory usage: 1.9+ KB None 12lemonade.describe()# describe() 함수를 사용하면 수치형 변수만을 기준으로 카운트, 평균, 표준편차, 최소/최대값, 4분의 수를 기준으로 25%, 50%, 75% 에 해당하는 값들을 테이블로 출력한다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Lemon Orange Temperature Leaflets Price count 32.000000 32.000000 32.000000 31.000000 32.000000 mean 116.156250 80.000000 78.968750 108.548387 0.354687 std 25.823357 21.863211 4.067847 20.117718 0.113137 min 71.000000 42.000000 70.000000 68.000000 0.250000 25% 98.000000 66.750000 77.000000 90.000000 0.250000 50% 113.500000 76.500000 80.500000 108.000000 0.350000 75% 131.750000 95.000000 82.000000 124.000000 0.500000 max 176.000000 129.000000 84.000000 158.000000 0.500000 count 행 내에 null(빈값, numpy의 NaN과 같은 취급)이 아닌 row의 개수를 센다. mean 모든 row에 있어 각 colum들의 값에 대한 평균값을 나타낸다. null값은 아예 없는 값으로 취급하여 분모에 들어가지 않는다. 즉 sum(모든 row의 값)/count 가 된다고 생각하면 된다. std 해당 column들의 값을에 대한 표준편차를 나타낸다. 역시 null값은 없는 값으로 취급한다. min, 25%, 50%, 75%, max 해당 column들의 값 중 최솟값, 사분위수, 최대값을 의미한다. 12lemonade['Location'].value_counts()해당열의 정보 갯수를 나타낸다. Beach 17 Park 15 Name: Location, dtype: int64 데이터 다뤄보기123lemonade['Sold'] = 0print(lemonade.head(3))#데이터에 sold 행을 추가함 Date Location Lemon Orange Temperature Leaflets Price sold Sold 0 7/1/2016 Park 97 67 70 90.0 0.25 0 0 1 7/2/2016 Park 98 67 72 90.0 0.25 0 0 2 7/3/2016 Park 110 77 71 104.0 0.25 0 0 123lemonade['Sold'] = lemonade['Lemon'] + lemonade['Orange']print(lemonade.head(3))# sold 행에 데이터 값을 지정함. (레몬과 오렌지 값을 더한 값) Date Location Lemon Orange Temperature Leaflets Price sold Sold 0 7/1/2016 Park 97 67 70 90.0 0.25 0 164 1 7/2/2016 Park 98 67 72 90.0 0.25 0 165 2 7/3/2016 Park 110 77 71 104.0 0.25 0 187 123lemonade['Revenue'] = lemonade['Price'] * lemonade['Sold']print(lemonade.head(3))# 새 행을 추가함과 동시에 값을 지정해줌. Date Location Lemon Orange ... Price sold Sold Revenue 0 7/1/2016 Park 97 67 ... 0.25 0 164 41.00 1 7/2/2016 Park 98 67 ... 0.25 0 165 41.25 2 7/3/2016 Park 110 77 ... 0.25 0 187 46.75 [3 rows x 10 columns] 12345pd.set_option('display.max_columns', None)lemonade['Revenue'] = lemonade['Price'] * lemonade['Sold']print(lemonade.head(3)) Date Location Lemon Orange Temperature Leaflets Price sold Sold \\ 0 7/1/2016 Park 97 67 70 90.0 0.25 0 164 1 7/2/2016 Park 98 67 72 90.0 0.25 0 165 2 7/3/2016 Park 110 77 71 104.0 0.25 0 187 Revenue 0 41.00 1 41.25 2 46.75 1234pd.set_option('display.max_columns', 0)lemonade['Revenue'] = lemonade['Price'] * lemonade['Sold']print(lemonade.head(3)) Date Location Lemon Orange ... Price sold Sold Revenue 0 7/1/2016 Park 97 67 ... 0.25 0 164 41.00 1 7/2/2016 Park 98 67 ... 0.25 0 165 41.25 2 7/3/2016 Park 110 77 ... 0.25 0 187 46.75 [3 rows x 10 columns] 12lemonade_column_drop = lemonade.drop('Sold', axis=1)print(lemonade_column_drop.head(3)) Date Location Lemon Orange ... Leaflets Price sold Revenue 0 7/1/2016 Park 97 67 ... 90.0 0.25 0 41.00 1 7/2/2016 Park 98 67 ... 90.0 0.25 0 41.25 2 7/3/2016 Park 110 77 ... 104.0 0.25 0 46.75 [3 rows x 9 columns] 12lemonade_row_drop = lemonade_column_drop.drop(0, axis=0)print(lemonade_row_drop.head(3)) Date Location Lemon Orange ... Leaflets Price sold Revenue 1 7/2/2016 Park 98 67 ... 90.0 0.25 0 41.25 2 7/3/2016 Park 110 77 ... 104.0 0.25 0 46.75 3 7/4/2016 Beach 134 99 ... 98.0 0.25 0 58.25 [3 rows x 9 columns] 데이터 인덱싱12print(lemonade[0:5])# 0부터 5개의 값을 가져옴 Date Location Lemon Orange ... Price sold Sold Revenue 0 7/1/2016 Park 97 67 ... 0.25 0 164 41.00 1 7/2/2016 Park 98 67 ... 0.25 0 165 41.25 2 7/3/2016 Park 110 77 ... 0.25 0 187 46.75 3 7/4/2016 Beach 134 99 ... 0.25 0 233 58.25 4 7/5/2016 Beach 159 118 ... 0.25 0 277 69.25 [5 rows x 10 columns] 1lemonade['Location'] == 'Beach' 0 False 1 False 2 False 3 True 4 True 5 True 6 True 7 True 8 True 9 True 10 True 11 True 12 True 13 True 14 True 15 True 16 True 17 True 18 False 19 False 20 False 21 False 22 False 23 False 24 False 25 False 26 False 27 False 28 False 29 False 30 True 31 True Name: Location, dtype: bool 12print(lemonade[lemonade['Location']=='Beach'].head(3)) # Beach인 데이터를 앞에서 3개 출력한다. Date Location Lemon Orange ... Price sold Sold Revenue 3 7/4/2016 Beach 134 99 ... 0.25 0 233 58.25 4 7/5/2016 Beach 159 118 ... 0.25 0 277 69.25 5 7/6/2016 Beach 103 69 ... 0.25 0 172 43.00 [3 rows x 10 columns] 12print(lemonade.iloc[0:3,0:2])# 0 부터 3개의 열 / 0부터 2개의 행을 출력한다 Date Location 0 7/1/2016 Park 1 7/2/2016 Park 2 7/3/2016 Park 12print(lemonade.loc[0:2,['Date','Location']])# 0부터 2개의 열 / date와 location 의 값을 출력한다. Date Location 0 7/1/2016 Park 1 7/2/2016 Park 2 7/3/2016 Park 기본 데이터 전처리1print(lemonade.sort_values(by=['Temperature']).head(5)) Date Location Lemon Orange ... Price sold Sold Revenue 0 7/1/2016 Park 97 67 ... 0.25 0 164 41.00 20 7/20/2016 Park 71 42 ... 0.50 0 113 56.50 2 7/3/2016 Park 110 77 ... 0.25 0 187 46.75 1 7/2/2016 Park 98 67 ... 0.25 0 165 41.25 16 7/16/2016 Beach 81 50 ... 0.50 0 131 65.50 [5 rows x 10 columns] 12lemonade.sort_values(by=['Temperature','Revenue'], ascending = False, inplace = True)print(lemonade.loc[:,['Date','Temperature','Revenue']].head(5)) Date Temperature Revenue 25 7/25/2016 84 134.50 12 7/12/2016 84 56.25 26 7/26/2016 83 106.75 11 7/11/2016 83 70.50 24 7/24/2016 82 101.50 1print(lemonade.groupby(by='Location').count()) Date Lemon Orange Temperature ... Price sold Sold Revenue Location ... Beach 16 17 17 17 ... 17 17 17 17 Park 15 15 15 15 ... 15 15 15 15 [2 rows x 9 columns] 1print(lemonade.groupby('Location')['Revenue'].agg([max,min])) max min Location Beach 95.5 43.0 Park 134.5 41.0 1print(lemonade.groupby('Location')[['Revenue','Sold']].agg([max,min])) Revenue Sold max min max min Location Beach 95.5 43.0 282 123 Park 134.5 41.0 305 113","link":"/2021/11/02/pandas_basic/"}],"tags":[{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[{"name":"python","slug":"python","link":"/categories/python/"}]}